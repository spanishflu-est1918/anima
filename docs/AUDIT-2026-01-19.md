# Anima Game Engine Audit Report

**Date:** January 19, 2026  
**Auditor:** Subagent (Hermes Workspace)  
**Scope:** Full codebase audit for console-first architecture readiness

---

## Executive Summary

The Anima game engine is a **point-and-click adventure framework** with two distinct components:

1. **StoryScript** (`packages/storyscript/`) — A line-by-line interpreter for `.story` files with no intermediate AST
2. **Phaser Engine** (`packages/engine/`) — A full Phaser 3-based game engine with UI, inventory, dialogue, and scene management

**Current State:** The engine is **playable via console REPL** but lacks several features required for a true **console-first architecture** that can serve both headless CI testing and GUI clients simultaneously.

---

## Part 1: What's DONE

### 1.1 StoryScript Interpreter Features

**File:** `packages/storyscript/src/interpreter.ts` (32KB)

| Feature | Status | Notes |
|---------|--------|-------|
| Scene parsing | ✅ Done | Full support for SCENE blocks with location, description, on_enter |
| Hotspots | ✅ Done | LOOK/TALK/USE actions per hotspot |
| Dialogue system | ✅ Done | DIALOGUE blocks with CHOICE branches |
| Inventory | ✅ Done | `GIVE item` command, `HAS(item)` conditionals |
| Flags/Variables | ✅ Done | `SET var = value`, comparison operators (`==`, `!=`, `>`, `<`, `>=`, `<=`) |
| Conditional logic | ✅ Done | `IF/ELSE/END` blocks |
| State machine | ✅ Done | Tracks scene, inventory, flags |
| Text blocks | ✅ Done | Multi-line text parsing (DESCRIPTION, ON_ENTER, CUTSCENE) |
| Goto transitions | ✅ Done | `-> scene_id` for scene transitions |
| Triggers | ✅ Done | REQUIRE conditions, CUTSCENE, -> goto |

**Example commands working in console mode:**

```storyscript
# Parsed correctly
SCENE bus_station
  location: "Arkham Bus Depot"
  DESCRIPTION
    "A small-town bus depot."
  END
END

GIVE bus_ticket        # Works
SET met_clerk = true   # Works
IF NOT HAS(ticket)     # Works
-> town_square         # Works
```

### 1.2 Console Mode REPL Commands

**File:** `packages/storyscript/src/interpreter.ts` (lines 480-530)

| Command | Action |
|---------|--------|
| `look`, `l` | Show current scene description |
| `look <target>` | Look at specific hotspot |
| `talk <target>` | Talk to NPC/hotspot |
| `use <target>` | Use hotspot |
| `hotspots`, `h` | List available hotspots |
| `inventory`, `inv`, `i` | Show inventory |
| `state`, `debug` | Show full game state (scene, inventory, flags) |
| `help`, `?` | Show help |
| `quit`, `exit`, `q` | Exit game |

### 1.3 Scene/Dialogue/Hotspot/Inventory Systems

#### Scene System (`packages/engine/src/scenes/`)
- `BaseScene.ts` — Core scene class with Phaser integration
- `ScenePreloadManager.ts` — Asset preloading
- `SceneTransitions.ts` — Scene switching with transitions

#### Dialogue System (`packages/engine/src/dialogue/`)
- `InkDialogueManager.ts` — Ink-format dialogue parsing
- `DialogueParser.ts` — Line-by-line parsing
- `StoryManager.ts` — Character story registration

#### Hotspot System (`packages/engine/src/hotspots/`)
- `Hotspot.ts` — Clickable area with verbs
- `RadialMenu.ts` — Verb selection UI

#### Inventory System (`packages/engine/src/inventory/`)
- `InventoryManager.ts` — Singleton with full inventory API
- Item definitions with progressive descriptions
- Item combination recipes
- Money management

### 1.4 Story Files Structure

**Location:** `adventures/shadow-over-innsmouth/story/`

```
act1.story  — 16,561 bytes (Bus station, journey)
act2.story  — 18,270 bytes (Hotel room, town square, investigation)
act3.story  — 8,549 bytes  (Church confrontation, chase)
act4.story  — 12,294 bytes (One year later, beach, ending)
```

**Format Example:**
```storyscript
SCENE scene_id
  location: "Location Name"
  time: morning|evening|night
  mood: tense|calm|mysterious
  
  DESCRIPTION
    "Narrative text here."
    speaker: "Dialogue."
  END
  
  ON_ENTER
    "Automatic events on entering."
  END
  
  HOTSPOT name [x, y, w, h]
    name: "Display Name"
    LOOK
      "Description when looking."
    END
    TALK
      -> dialogue_id
    END
    USE
      "Action when using."
    END
  END
END

DIALOGUE dialogue_id
  speaker: "Text."
  CHOICE
    > "Option 1"
      -> scene_id
    > "Option 2"
      -> END
  END
END

TRIGGER trigger_id
  REQUIRE condition
  CUTSCENE
    "Cutscene content."
  END
  -> target
END
```

---

## Part 2: What's MISSING for Console-First Architecture

### 2.1 Game State Exposure via Console

| Missing Feature | Current State | Required |
|-----------------|---------------|----------|
| Read-only state API | Partial (`state` command) | Full state object with JSON export |
| State mutation API | Internal only | Console commands to SET flags, add items |
| State save/load | None | `save <slot>`, `load <slot>` |
| State diff/rollback | None | `undo`, `history` |
| Watch state changes | None | `watch flag_name` |
| Export state to JSON | None | `export state.json` |

**Current implementation** (`interpreter.ts` lines 515-518):
```typescript
if (cmd === 'state' || cmd === 'debug') {
  this.showState();
}
```
Only shows a simple console log — no programmatic access.

### 2.2 Event Bus for GUI Subscription

| Component | Has Event Bus? | Notes |
|-----------|----------------|-------|
| `UIState` | ✅ Yes | Observer pattern with `subscribe()` |
| `GameState` | ❌ No | Direct mutation only |
| `InventoryManager` | ⚠️ Partial | Uses UIState callbacks |
| `SceneManager` | ❌ No | No events |
| `DialogueManager` | ⚠️ Partial | `DialogueCallbackHandler` only |

**Current UIState subscription pattern** (`packages/engine/src/ui/UIState.ts`):
```typescript
public subscribe(callback: Subscriber): () => void {
  this.subscribers.add(callback);
  return () => {
    this.subscribers.delete(callback);
  };
}
```

**Missing for console-first:**
- No centralized `EventEmitter` for cross-module events
- No event types defined (scene change, dialogue start/end, inventory change)
- StoryScript interpreter has no event emission
- No way for headless clients to subscribe to game events

### 2.3 Headless Mode for CI

| Feature | Status | Impact |
|---------|--------|--------|
| Phaser-free interpreter | ✅ Exists | `interpreter.ts` runs standalone |
| Test runner integration | ⚠️ Minimal | `pnpm test` runs vitest only |
| StoryScript unit tests | ❌ None | No test coverage for parser |
| Game state assertions | ❌ No | Cannot assert state in CI |
| Automated playthrough | ❌ No | No scriptable runner |
| Headless browser tests | ❌ No | No Puppeteer/Playwright tests |

**Current test setup** (`vitest.config.ts`):
```typescript
include: ["packages/**/*.test.ts", "api/**/*.test.ts"]
```
- Only `packages/engine/` has tests
- `packages/storyscript/` has **zero tests**

### 2.4 Location-Dependent NPC Triggers

| Feature | Status | Notes |
|---------|--------|-------|
| Scene ON_ENTER events | ✅ Exists | `ON_ENTER` block in each scene |
| NPC appearance based on location | ❌ No | NPCs are static, not location-aware |
| NPC departure when leaving | ❌ No | No "on exit" handlers |
| Time-based NPC schedules | ❌ No | Cannot say "NPC X is at location Y at 6 PM" |
| Conditional NPC dialogue | ⚠️ Partial | Only via dialogue branches, not location |
| Multiple NPCs per scene | ✅ Exists | Hotspots can have TALK actions |

**Current limitation:** NPCs are embedded in scene hotspots but have no independent state machine for:
- Tracking where they are
- Moving between scenes
- Time-of-day availability
- Quest-state-dependent presence

---

## Part 3: What Needs to Be Built

### 3.1 Gap Analysis: Current vs Console-First Vision

| Component | Current State | Console-First Target | Gap |
|-----------|---------------|----------------------|-----|
| **Interpreter** | Standalone TSX | Library + CLI | Package as ESM, export API |
| **State Management** | Private fields | Exposable via console | Add `getState()`, `setState()` |
| **Event Bus** | UIState only | Global EventEmitter | Create `GameEvents` class |
| **CLI** | Simple REPL | Full-featured console | Add `save`, `load`, `export` |
| **Headless Mode** | Exists (basic) | CI-ready | Add assertions, scripts |
| **NPC System** | Static hotspots | Location-aware | Add `NPCManager` |
| **Tests** | Engine only | Full coverage | Add StoryScript tests |

### 3.2 Specific Features/Functions Needed

#### 3.2.1 StoryScript Package Restructuring

```
packages/storyscript/
├── src/
│   ├── index.ts          # Export interpreter class
│   ├── interpreter.ts    # Keep as is
│   ├── types.ts          # NEW: Export all interfaces
│   ├── events.ts         # NEW: GameEventEmitter
│   └── cli.ts            # NEW: Enhanced CLI with commands
├── dist/
├── package.json          # Update to export main, types
└── test/
    ├── interpreter.test.ts
    └── fixtures/
        ├── basic.story
        └── conditional.story
```

#### 3.2.2 New Classes Required

**1. `GameEventEmitter` (new file)**
```typescript
export type GameEvent = 
  | { type: 'scene:change'; sceneId: string }
  | { type: 'scene:enter'; sceneId: string }
  | { type: 'dialogue:start'; dialogueId: string }
  | { type: 'dialogue:end'; dialogueId: string }
  | { type: 'inventory:add'; itemId: string }
  | { type: 'inventory:remove'; itemId: string }
  | { type: 'flag:change'; key: string; value: any }
  | { type: 'trigger:fire'; triggerId: string };

export class GameEventEmitter {
  on<T extends GameEvent>(type: T['type'], handler: (event: T) => void): void;
  emit(event: GameEvent): void;
  off<T extends GameEvent>(type: T['type'], handler: Function): void;
}
```

**2. `GameStateAPI` (new class, for console exposure)**
```typescript
export class GameStateAPI {
  getState(): GameStateSnapshot;
  setFlag(key: string, value: string|number|boolean): void;
  getFlag<T>(key: string): T | undefined;
  addItem(itemId: string): void;
  removeItem(itemId: string): void;
  getInventory(): string[];
  hasItem(itemId: string): boolean;
  save(slot: number): void;
  load(slot: number): void;
  export(): string; // JSON
  import(json: string): void;
  reset(): void;
}
```

**3. `NPCManager` (new class, location-dependent NPCs)**
```typescript
export class NPCManager {
  registerNPC(id: string, config: NPCConfig): void;
  setNPCLocation(npcId: string, sceneId: string): void;
  getNPCLocation(npcId: string): string | null;
  getNPCsInScene(sceneId: string): NPC[];
  setNPCSchedule(npcId: string, schedule: TimeSlot[]): void;
  getAvailableNPCs(sceneId: string, time: string): NPC[];
}
```

#### 3.2.3 CLI Commands to Add

| Command | Description |
|---------|-------------|
| `get <path>` | Get nested state (e.g., `get flags.met_clerk`) |
| `set <path> <value>` | Set state value |
| `watch <path>` | Watch for state changes |
| `save <slot>` | Save game to slot (1-9) |
| `load <slot>` | Load game from slot |
| `export` | Export state as JSON |
| `import <json>` | Import state from JSON |
| `goto <scene>` | Jump to scene |
| `items` | List inventory with details |
| `npcs` | List NPCs and their locations |
| `acts` | List all available act files |
| `run <file>` | Run a story file non-interactively |
| `script <file>` | Run a sequence of console commands |

#### 3.2.4 Headless/CI Features

**1. Non-interactive runner mode:**
```bash
tsx interpreter.ts act1.story --headless --script test-acts.js
```

**2. Assertion API for tests:**
```typescript
// test-acts.js
await interpreter.runTo('hotel_room');
assert(interpreter.hasItem('notebook'));
assert(interpreter.getFlag('visited_square') === true);
```

**3. Test fixtures:**
```typescript
// interpreter.test.ts
describe('StoryInterpreter', () => {
  it('parses scene with hotspots', async () => {
    const interpreter = new StoryInterpreter();
    interpreter.load('fixtures/basic.story');
    assert(interpreter.getScene() === 'bus_station');
  });
});
```

### 3.3 Recommended Implementation Order

| Priority | Item | Effort | Impact |
|----------|------|--------|--------|
| P0 | Export StoryInterpreter class | Low | Enables API usage |
| P0 | Add `getState()` method | Low | Enables inspection |
| P1 | Create `GameEventEmitter` | Medium | Enables GUI sync |
| P1 | Add state save/load | Medium | Gameplay feature |
| P2 | CLI enhancements | Medium | DX improvement |
| P2 | NPCManager for location-aware NPCs | High | Major feature |
| P2 | StoryScript unit tests | Medium | Quality gate |
| P3 | Headless runner with assertions | High | CI integration |
| P3 | Event types documentation | Low | Developer docs |

---

## Appendix A: File Reference

| File | Purpose | Lines |
|------|---------|-------|
| `packages/storyscript/src/interpreter.ts` | Core interpreter | 900+ |
| `packages/engine/src/ui/UIState.ts` | Observable UI state | 180 |
| `packages/engine/src/state/GameState.ts` | Game state singleton | 140 |
| `packages/engine/src/inventory/InventoryManager.ts` | Inventory system | 280 |
| `packages/engine/src/characters/Character.ts` | Character sprite | 260 |
| `packages/engine/src/dialogue/InkDialogueManager.ts` | Ink dialogue | 180 |

## Appendix B: Console Mode Walkthrough

```bash
$ tsx packages/storyscript/src/interpreter.ts adventures/shadow-over-innsmouth/story/act1.story

=== StoryScript Interpreter ===

=== Arkham Bus Depot ===

A small-town bus depot. Diesel and stale coffee.
Fluorescent lights hum and flicker.
A hand-written schedule lists two destinations: BOSTON and INNSMOUTH.

> help
Commands:
  look, l           - Look around (scene description)
  look <target>     - Look at something
  talk <target>     - Talk to someone/something
  use <target>      - Use something
  hotspots, h       - List available hotspots
  inventory, inv, i - Show inventory
  state, debug      - Show game state
  quit, exit, q     - Exit game

> hotspots

Hotspots:
  Ticket Window [look, talk]
  Schedule Board [look]
  Waiting Bench [look, talk]
  Vending Machine [look, use]
  Bus Platform [use]

> look ticket_window
Scratched plexiglass. A faded schedule.
Someone scratched 'DONT GO' into the counter.

> state
--- Game State ---
Scene: bus_station
Inventory: []
Flags: {}
```

---

## Appendix C: Related Documentation

- `docs/STORYSCRIPT.md` — Full StoryScript specification
- `CLAUDE.md` — Project context and conventions
- `packages/engine/src/` — Engine API reference

---

*Report generated January 19, 2026*
